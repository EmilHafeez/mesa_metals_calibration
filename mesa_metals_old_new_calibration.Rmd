---
title: "MESA Metals 2: Examining Variability within Calibration Curves"
author: ""
geometry: "left=2.57cm,right=2.57cm,top=2.57cm,bottom=2.57cm"
output:
  pdf_document:
    latex_engine: xelatex
    toc: yes
    toc_depth: 3
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
header-includes:
- \usepackage{fancyhdr}
- \usepackage{lipsum}
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
- \pagestyle{fancy}
- \fancyhead[R]{\thepage}
- \fancypagestyle{plain}{\pagestyle{fancy}}
--- 

\newpage

# Section 1: Setup & Summary

Let's revisit the regression analysis and compare old and new calibrations, using the new (5/10/21) dataset. Mostly, this is to make sure there aren't systematic differences (between old and new calibrations), and then we can move into the lower range to determine values that were below the LOD. 


## Summary

Overall, the procedure is as follows:
    1. Run a regression for a single calibration and single data of a single chemical (arsenic chosen)
    2. Run a regression for all calibration runs of a single chemical (also arsenic)
    3. Run regressions of all runs on all chemicals. This step is likely of the most interest.
      1. Print plots of these regressions, and also print plots of the intercepts versus their slopes.
      
By plotting, we can examinine the variability between regression lines per each calibration run, as well as examining the slopes versus the intercepts (since this may be helpful later). See Section 6. 

```{r, include = F}
library(tidyverse)
library(readxl)
library(modelr)
library(openxlsx)
library(patchwork)
```

```{r, include = F}
set.seed(1107)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
knitr::opts_chunk$set(echo = TRUE)
options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis",
  ggplot2.discrete.colour = "viridis",
  ggplot2.discrete.fill = "viridis"
)

knitr::opts_chunk$set(fig.align="center")

```

\newpage

# Section 2: Arsenic Case Study, Regression Results Replication Attempt

This section reads in just one elements calibration data (arsenic only). Then, we fit a regression to this (the raw counts divided by internal standard, minus the calibration blank).

```{r, include = F}
#read in, basic tidy, iterate labels to make nesting possible, as in the first dataset
As_df = read_excel(
  "./data/210429_MESA totals calibration comparison_for Jeff and Emil.xlsx", 
  sheet = "As",
  range = "A2:E56") %>% 
  janitor::clean_names() %>% 
  rename(
    concentration_ug_old = concentration_ug_l_1,
    concentration_ug_new =  concentration_ug_l_4,
    net_signal_old = net_signal_counts_per_second_2,
    net_signal_new = net_signal_counts_per_second_5,
    no_cal_old = x3
  ) %>% 
  mutate(
    no_cal_new = NA
  ) %>% 
  mutate(
    run_old = rep(1:7, length.out = 54),
    run_new = rep(1:11, length.out = 54)
  ) %>% 
  mutate(
    no_cal_old = rep(1:8, each = 7, length.out = 54),
    no_cal_new = rep(1:8, each = 11, length.out = 54)
  ) %>% 
  select(no_cal_old, run_old, concentration_ug_old, net_signal_old, no_cal_new, run_new, concentration_ug_new, net_signal_new, everything())
```

```{r, include = F}
#test a case
As_df_test = 
  As_df %>% 
  filter(no_cal_old == 1)

glm_fit = glm(net_signal_old ~ concentration_ug_old, 
    data = As_df_test,
    family = gaussian(link = "identity")) 
```

Printing the regression output,

```{r}
summary(glm_fit)
```

It would be helpful to compare this result to what Kathrin and Rony produce using the spectroscope software, since this is not in the Excel sheet. It should match exactly. 

# Section 3: Iterate Regression for All Arsenic

Let's iterate the regression for each calibration run, for one element (As).
```{r, include = F}
#let's do both the old and the new results separately and then combine
#old
As_old_results_df =
  As_df %>%
  filter(!is.na(concentration_ug_old)) %>% 
  select(no_cal_old, run_old, concentration_ug_old, net_signal_old) %>% 
  nest(data = c(run_old, concentration_ug_old, net_signal_old)) %>%
  mutate(
    models =
      map(.x = data, ~glm(net_signal_old ~ concentration_ug_old, data = .x,
                     family = gaussian(link = "identity"))),
    results = map(models, broom::tidy)
  ) %>%
  select(no_cal_old, results) %>%
  unnest(results)
#new
As_new_results_df =
  As_df %>%
  filter(!is.na(concentration_ug_new)) %>% 
  select(no_cal_new, run_new, concentration_ug_new, net_signal_new) %>% 
  nest(data = c(run_new, concentration_ug_new, net_signal_new)) %>%
  mutate(
    models =
      map(.x = data, ~glm(net_signal_new ~ concentration_ug_new, data = .x,
                     family = gaussian(link = "identity"))),
    results = map(models, broom::tidy)
  ) %>%
  select(no_cal_new, results) %>%
  unnest(results)

#join
As_results_df = 
  bind_rows(As_old_results_df, As_new_results_df) %>% 
  mutate(
    old_new_identifier = rep(c("old_data", "new_data"), each = 14, length.out = 24)
  )
```

# Section 4: Plot Arsenic Regression Lines and Intercept vs Slope

Then we look at these regression lines for arsenic. Each unique calibration run is its own regression line, as in the Excel structure. For brevity, we just do the newer arsenic data (and then we'll look at all old and new data for all elements later).

```{r, echo = F}
As_df %>% 
  mutate(no_cal_new = as.factor(no_cal_new)) %>% 
  filter(!is.na(concentration_ug_new)) %>% 
ggplot(
  aes(
    x = concentration_ug_new, 
    y = net_signal_new, 
    group = no_cal_new, 
    color = no_cal_new,
    shape = no_cal_new)
  ) +
  stat_smooth(method = "lm", formula = y ~ x, se = F, size = .75) + 
  geom_point(size = 3) + 
    labs(color = "Regressions per Calibration",
         shape = "Regressions per Calibration",
         title = "Regressing Corrected Sample Concentration on Standard Concentration", 
         caption = "Examining the variability of arsenic as a case study") +
    scale_shape_manual(values=seq(0,7))
```

Focusing on these regression lines based on the newer arsenic data, let's take a look at the intercepts against the slopes. Note that the vertical line at 0 is for reference.
```{r, echo = F}
As_new_results_df %>% 
  select(no_cal_new, term, estimate) %>% 
  pivot_wider(
    names_from = "term",
    values_from = c("estimate")) %>% 
  rename(intercept = c("(Intercept)")) %>% 
  rename(beta_hat = c("concentration_ug_new")) %>% 
  mutate(no_cal_new = as.factor(no_cal_new)) %>% 
ggplot(
  aes(
    x = intercept, 
    y = beta_hat, 
    group = no_cal_new, 
    color = no_cal_new,
    shape = no_cal_new)
  ) +
  geom_point(size = 3) + 
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.25) +
    labs(color = "Regressions per Calibration",
         shape = "Regressions per Calibration",
         title = "Visualizing Intercepts vs Slopes", 
         caption = "Examining the variability of arsenic as a case study") +
    scale_shape_manual(values=seq(49,57))
```

# Section 5: All Elements Data Manipulation

Great. Now we's work on iterating for all elements (organized per Excel sheets within the workbook). I read in the data, then, iterate the regressions for each of the (calibration) groups within each element.
```{r, include = F}
path =
  "./data/210429_MESA totals calibration comparison_for Jeff and Emil.xlsx"

mesa_metals_list = path %>%
  excel_sheets() %>%
  set_names() %>%
  map(read_excel, 
      path = path, 
      range = "A3:E56", 
      col_names = c("concentration_ug_old","net_signal_old","x3","concentration_ug_new","net_signal_new"))

```

```{r, include = F}
mesa_metals_df = as_tibble(matrix(mesa_metals_list)) %>% 
  rename(elements_data = V1)

mesa_metals_df = 
  mesa_metals_df %>% 
  add_column(elements = c("cobalt_Co", "nickel_Ni", "zinc_Zn", "copper_Cu", "strontium_Sr", "molybdenum_Mo", "cesium_Cs", "barium_Ba", "tungsten_W", "thallium_Tl", "lead_Pb", "uranium_U", "manganese_Mn", "selenium_Se", "arsenic_As", "cadmium_Cd")) %>% 
  select(elements, everything())

mesa_metals_df =
  mesa_metals_df %>%
  unnest(cols = elements_data)
```

```{r, include = F}
mesa_metals_df = 
  mesa_metals_df %>% 
rename(
    no_cal_old = x3
  ) %>% 
  mutate(
    no_cal_new = NA
  ) %>% 
  group_by(elements) %>% 
  mutate(
    no_cal_old = rep(1:7, each = 7, length.out = length(elements)),
    no_cal_new = rep(1:5, each = 11, length.out = length(elements))
  ) %>% 
  ungroup(elements) %>% 
  select(elements, no_cal_old, concentration_ug_old, net_signal_old, no_cal_new, concentration_ug_new, net_signal_new, everything())
```

# Section 6: Plot All Elements

Then, we're in a position to visualize the regression lines, and we also add the raw data to the plot. Note that the calibration ranges have changed for some elements, and this impacts the way the results look. However, even with that note, there does appear to be more consistency in the new calibration method.

\pagestyle{fancy}
\fancyhf{}
\newpage
\paperwidth=\pdfpageheight
\paperheight=\pdfpagewidth
\pdfpageheight=\paperheight
\pdfpagewidth=\paperwidth
\headwidth=\textheight
\begingroup 
\vsize=\textwidth
\hsize=\textheight

```{r, include = F}
rm(As_df, As_df_test, As_new_results_df, As_results_df, As_old_results_df, glm_fit)
```

## Section 6a: Regression Lines

First, let's look at each calibration run separately. The old data have 6 data points per calibration run, and 7 calibration runs per element. The new data have 10 daata points per calibration run, and 5 calibration runs per element. There are 16 elements. Resolution is set very high to fit it on one page, please zoom in.

```{r, message = F, warning = F, echo = F, fig.width= 25.37, fig.height = 19.02}
ggplot_old_calibrations =
  mesa_metals_df %>%
  mutate(no_cal_old = as.factor(no_cal_old)) %>%
ggplot(
  aes(
    x = concentration_ug_old,
    y = net_signal_old,
    group = no_cal_old,
    color = no_cal_old,
    shape = no_cal_old,
  )
  ) +
  stat_smooth(method = "lm", formula = y ~ x, se = F, size = .75) +
  geom_point() +
    labs(color = "Regressions per Calibration",
         shape = "Regressions per Calibration",
         title = "Regressing Old Data, Corrected Sample Concentration on Standard Concentration",
         subtitle = "Faceted by Elements",
         caption = "Examining the variability between regression lines, by element, per calibration group") +
  facet_wrap(~elements, scales = "free") +
    scale_shape_manual(values=seq(0,9))

ggplot_new_calibrations =
  mesa_metals_df %>%
  mutate(no_cal_old = as.factor(no_cal_old)) %>%
ggplot(
  aes(
    x = concentration_ug_old,
    y = net_signal_old,
    group = no_cal_old,
    color = no_cal_old,
    shape = no_cal_old,
  )
  ) +
  stat_smooth(method = "lm", formula = y ~ x, se = F, size = .75) +
  geom_point() +
    labs(color = "Regressions per Calibration Number",
         shape = "Regressions per Calibration Number",
         title = "Regressing New Data, Corrected Sample Concentration on Standard Concentration",
         subtitle = "Faceted by Elements",
         caption = "Examining the variability between regression lines, by element, per calibration group") +
  facet_wrap(~elements, scales = "free") +
    scale_shape_manual(values=seq(0,9))
```

```{r, message = F, warning = F, echo = F, fig.width= 25.37, fig.height = 19.02}
patchwork_old_calibrations = 
  mesa_metals_df %>% 
  mutate(no_cal_old = as.factor(no_cal_old)) %>% 
ggplot(
  aes(
    x = concentration_ug_old, 
    y = net_signal_old, 
    group = no_cal_old, 
    color = no_cal_old,
    shape = no_cal_old,
  )
  ) +
  stat_smooth(method = "lm", formula = y ~ x, se = F, size = .75) +
  geom_point() + 
    labs(color = "Regression for Calibration Number",
         shape = "Regression for Calibration Number",
         title = "Old Data") +
  facet_wrap(~elements, scales = "free") +
    scale_shape_manual(values=seq(0,9))

patchwork_new_calibrations = 
  mesa_metals_df %>% 
  mutate(no_cal_new = as.factor(no_cal_new)) %>% 
ggplot(
  aes(
    x = concentration_ug_new, 
    y = net_signal_new, 
    group = no_cal_new, 
    color = no_cal_new,
    shape = no_cal_new,
  )
  ) +
  stat_smooth(method = "lm", formula = y ~ x, se = F, size = .75) +
  geom_point() + 
    labs(color = "Regression for Calibration Number",
         shape = "Regression for Calibration Number",
         title = "New Data") +
  facet_wrap(~elements, scales = "free") +
    scale_shape_manual(values=seq(0,9)) + 
  theme(legend.position = "none")


(patchwork_old_calibrations + patchwork_new_calibrations) + 
  plot_layout(guides = "collect") +
  plot_annotation(
    title = "Regressing Corrected Sample Concentration on Standard Concentration",
    subtitle = "Per Calibration Run and Per Element",
    caption = "Examining the variability between regression lines, by element, per calibration group. Note the old/new data distinction"
  )
```

```{r lengthening the data, include = F}
mesa_metals_df_longer_old =
  mesa_metals_df %>% 
  select(elements, no_cal_old, concentration_ug_old, net_signal_old) %>% 
  mutate(
    recency = "old"
  ) %>% 
  rename(
    no_cal = no_cal_old,
    concentration_ug = concentration_ug_old,
    net_signal = net_signal_old
  ) %>% filter(!is.na(concentration_ug))

mesa_metals_df_longer_new =
  mesa_metals_df %>%
  select(elements, no_cal_new, concentration_ug_new, net_signal_new) %>% 
  mutate(
    recency = "new"
  ) %>% 
  rename(
    no_cal = no_cal_new,
    concentration_ug = concentration_ug_new,
    net_signal = net_signal_new
  ) %>% filter(!is.na(concentration_ug))

mesa_metals_df_longer = 
  rbind(mesa_metals_df_longer_old, mesa_metals_df_longer_new)

rm(mesa_metals_df_longer_old, mesa_metals_df_longer_new)
```

Then, let's look at the new versus the old data, maintaining each regression line, but color-coding simply so can compare easily. While the standardized concentration ranges (x-axis) vary from the old to the new data, we overlay the graphs anyways, to get a sense of what consistency is there. Note the special case of lead (Pb). 

```{r plot the overlapping data, message = F, warning = F, echo = F, fig.width= 25.37, fig.height = 19.02}
mesa_metals_df_longer %>%
  mutate(elements = as.factor(elements),
         no_cal = as.factor(no_cal),
         recency = as.factor(recency)
         ) %>%
ggplot(
  aes(
    x = concentration_ug,
    y = net_signal,
    group = interaction(recency, no_cal),
    color = interaction(recency),
    shape = interaction(recency, no_cal)
  )
  ) +
  stat_smooth(method = "lm", formula = y ~ x, se = F, size = .75) +
  geom_point(show.legend = FALSE) +
    labs(color = "Regressions per Calibration",
         shape = "Regressions per Calibration",
         title = "Regressing Corrected Sample Concentration on Standard Concentration: Old Vs New Data",
         subtitle = "Per Calibration Run and Per Element",
         caption = "Examining the variability between regression lines, by element, per calibration group") +
  facet_wrap(~elements, scales = "free") +
    scale_shape_manual(values=seq(49,60))
```

## Section 6b: Intercept and Slope Coefficients

```{r message=FALSE, warning=FALSE, include=F}
#make the regression results df for the new and old data
mesa_metals_old_results_df =
  mesa_metals_df %>%
  #filter(!is.na(concentration_ug_old)) %>% 
  select(elements, no_cal_old, concentration_ug_old, net_signal_old) %>% 
  nest(data = c(concentration_ug_old, net_signal_old)) %>%
  mutate(
    models =
      map(.x = data, ~glm(net_signal_old ~ concentration_ug_old, data = .x,
                     family = gaussian(link = "identity"))),
    results = map(models, broom::tidy)
  ) %>%
  select(elements, no_cal_old, results) %>%
  unnest(results)
#new
mesa_metals_new_results_df =
  mesa_metals_df %>%
  #filter(!is.na(concentration_ug_old)) %>% 
  select(elements, no_cal_new, concentration_ug_new, net_signal_new) %>% 
  nest(data = c(concentration_ug_new, net_signal_new)) %>%
  mutate(
    models =
      map(.x = data, ~glm(net_signal_new ~ concentration_ug_new, data = .x,
                     family = gaussian(link = "identity"))),
    results = map(models, broom::tidy)
  ) %>%
  select(elements, no_cal_new, results) %>%
  unnest(results)

#join
mesa_metals_results_df = 
  bind_rows(mesa_metals_old_results_df, mesa_metals_new_results_df) %>% 
  mutate(
    old_new_identifier = rep(c("old_data", "new_data"), each = 224, length.out = 384)
  )
```

Now, similar to the first regression lines plot, we look at the intercepts versus slopes (x-axis and y-axis respectively) for each of the regressions. This first separates old and new data, per calibration run and per element, and then overlays old and new data (with a simple color-code).

```{r intercepts vs slopes, echo = F, message = F, warning = F, include = T, fig.width= 25.37, fig.height = 19.02}
patchwork_old_results = 
  mesa_metals_old_results_df %>% 
  select(elements,no_cal_old, term, estimate) %>% 
  pivot_wider(
    names_from = "term",
    values_from = c("estimate")) %>% 
  rename(intercept = c("(Intercept)")) %>% 
  rename(beta_hat = c("concentration_ug_old")) %>% 
  mutate(no_cal_old = as.factor(no_cal_old)) %>% 
ggplot(
  aes(
    x = intercept, 
    y = beta_hat, 
    group = no_cal_old, 
    color = no_cal_old,
    shape = no_cal_old
    )
  ) +
  geom_point(size = 3) + 
    labs(color = "Regressions per Calibration Number",
         shape = "Regressions per Calibration Number",
         title = "Old Data") +
  facet_wrap(~elements, scales = "free") +
    scale_shape_manual(values=seq(49,57)) + 
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.25)

patchwork_new_results = 
  mesa_metals_new_results_df %>% 
  select(elements,no_cal_new, term, estimate) %>% 
  pivot_wider(
    names_from = "term",
    values_from = c("estimate")) %>% 
  rename(intercept = c("(Intercept)")) %>% 
  rename(beta_hat = c("concentration_ug_new")) %>% 
  mutate(no_cal_new = as.factor(no_cal_new)) %>% 
ggplot(
  aes(
    x = intercept, 
    y = beta_hat, 
    group = no_cal_new, 
    color = no_cal_new,
    shape = no_cal_new
    )
  ) +
  geom_point(size = 3) + 
    labs(color = "Regressions per Calibration Number",
         shape = "Regressions per Calibration Number",
         title = "New Data", 
         subtitle = "Faceted by elements") +
  facet_wrap(~elements, scales = "free") +
    scale_shape_manual(values=seq(49,57)) + 
  theme(legend.position = "none") + 
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.25)


(patchwork_new_results + patchwork_old_results) + 
  plot_layout(guides = "collect") +
  plot_annotation(
    title = "Plotting Intercepts vs Slopes for Regressions",
    subtitle = "Per Calibration Run and Per Element",
    caption = "Examining the variability between regressing corrected sample concentration on standard concentration, per element, per calibration group. Note the old/new data distinction."
  )
```

```{r intercepts vs slopes overlay, echo = F, message = F, warning = F, include = T, fig.width= 25.37, fig.height = 19.02}
mesa_metals_results_df %>%
  select(elements, no_cal_old, no_cal_new, term, estimate, old_new_identifier) %>%
  pivot_wider(
    names_from = "term",
    values_from = c("estimate")) %>%
  rename(intercept = c("(Intercept)")) %>%
  rename(beta_hat = c("concentration_ug_old", "concentration_ug_new")) %>%
  mutate(
    no_cal_old = as.factor(no_cal_old),
    no_cal_new = as.factor(no_cal_new),
    beta_hat_combined = coalesce(beta_hat1, beta_hat2),
    elements = as.factor(elements),
    old_new_identifier = as.factor(old_new_identifier)
    ) %>%
  rename(beta_hat_old_coefficient = "beta_hat1",
         beta_hat_new_coefficient = "beta_hat2") %>%
  mutate(
    no_cal_combined = coalesce(no_cal_old, no_cal_new)
  ) %>% 
  ggplot(
  aes(
    x = intercept,
    y = beta_hat_combined,
    group = interaction(old_new_identifier, no_cal_combined),
    color = interaction(old_new_identifier),
    shape = interaction(old_new_identifier)
    )
  ) +
  geom_point(size = 3) + 
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.25) +
    labs(color = "Regressions per Calibration",
         shape = "Regressions per Calibration",
         title = "Plotting Intercepts vs Slopes for Regressions (x = intercept, y = slope)",
         subtitle = "Per Calibration Run and Per Element",
         caption = "Examining the variability between regressing corrected sample concentration on standard concentration, per element, per calibration group. Note the old/new data distinction") +
  facet_wrap(~elements, scales = "free") +
    scale_shape_manual(values=seq(49,60))
```

# Section 7: Comparing Regression Scenarios

Great. Now, we want to compare the calibration fits for different scenarios. Let's compare 1) the existing calibration fits which use all available data versus only if we fit using the low range data points, 2) using only the original calibration points (0, 0.05, 0.1, 0.25, 0.5, and 1 ppb). 












\endgroup
\newpage
\paperwidth=\pdfpageheight
\paperheight=\pdfpagewidth
\pdfpageheight=\paperheight
\pdfpagewidth=\paperwidth
\headwidth=\textwidth
